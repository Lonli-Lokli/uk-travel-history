/* eslint-disable no-empty-pattern */
import { test, expect, type Page, TestInfo } from '@playwright/test';
import AxeBuilder from '@axe-core/playwright';
import type { Result as AxeResult, NodeResult } from 'axe-core';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Accessibility E2E Tests for UK Travel History Parser
 *
 * This test suite uses axe-core to automatically scan for accessibility violations,
 * with a strong focus on color contrast and WCAG compliance.
 *
 * Tests are performed on both the landing page and travel page to ensure accessibility
 * across all user journeys.
 *
 * If violations are found, the test fails and generates a detailed accessibility-report.md file.
 */

// Suite-level violation tracking
interface ViolationRecord {
  testName: string;
  url: string;
  violations: AxeResult[];
}

const suiteViolations: Map<string, ViolationRecord[]> = new Map();

test.describe('Accessibility Tests', () => {
  // Ensure accessibility-reports directory exists before any tests run
  test.beforeAll(() => {
    const reportDir = path.join(
      process.cwd(),
      '..',
      '..',
      'accessibility-reports',
    );
    console.log(`Attempting to create directory at: ${reportDir}`);

    if (!fs.existsSync(reportDir)) {
      fs.mkdirSync(reportDir, { recursive: true });
      console.log(`Directory created successfully at: ${reportDir}`);
    } else {
      console.log(`Directory already exists at: ${reportDir}`);
    }

    // Create README to ensure directory is never empty (for artifact upload)
    const readmePath = path.join(reportDir, 'README.md');
    if (!fs.existsSync(readmePath)) {
      fs.writeFileSync(
        readmePath,
        '# Accessibility Reports\n\n' +
          'This directory contains accessibility test reports generated by Playwright.\n\n' +
          'If this is the only file here, no accessibility violations were found!\n',
        'utf-8',
      );
    }
  });

  test.describe('Landing Page Accessibility', () => {
    const suiteName = 'Landing Page Accessibility';

    test('should not have accessibility violations on landing page', async ({
      page,
    }) => {
      // Navigate to the landing page
      await page.goto('/');
      await page.waitForLoadState('domcontentloaded');

      // Run accessibility scan and collect violations
      await collectAccessibilityViolations(page, 'Landing Page', suiteName);
    });

    test('should have accessible import buttons', async ({ page }) => {
      await page.goto('/');
      await page.waitForLoadState('domcontentloaded');

      // Check that buttons have accessible names
      const pdfButton = page.getByRole('button', { name: /Import from PDF/i });
      const excelButton = page.getByRole('button', {
        name: /Import from Excel/i,
      });
      const clipboardButton = page.getByRole('button', {
        name: /Import from Clipboard/i,
      });
      const manualButton = page.getByRole('button', {
        name: /add travel dates manually/i,
      });

      await expect(pdfButton).toBeVisible();
      await expect(excelButton).toBeVisible();
      await expect(clipboardButton).toBeVisible();
      await expect(manualButton).toBeVisible();

      // Run focused accessibility scan on button container
      const buttonContainer = page.locator('div').filter({
        has: pdfButton,
      });
      const accessibilityScanResults = await new AxeBuilder({ page })
        .include(await buttonContainer.elementHandle().then((el) => el!))
        .withTags(['wcag2a', 'wcag2aa'])
        .analyze();

      expect(accessibilityScanResults.violations).toEqual([]);
    });

    test('should have accessible external links', async ({ page }) => {
      await page.goto('/');
      await page.waitForLoadState('domcontentloaded');

      // Check SAR link has proper attributes
      const sarLink = page.getByRole('link', {
        name: /Request your travel history document/i,
      });
      await expect(sarLink).toBeVisible();

      // Verify it opens in new tab with security attributes
      await expect(sarLink).toHaveAttribute('target', '_blank');
      await expect(sarLink).toHaveAttribute('rel', /noopener/);

      // Check Buy Me a Coffee link
      const coffeeLink = page
        .getByRole('link', { name: /Buy Me a Coffee/i })
        .first();
      await expect(coffeeLink).toBeVisible();
      await expect(coffeeLink).toHaveAttribute('target', '_blank');
      await expect(coffeeLink).toHaveAttribute('rel', /noopener/);
    });

    test.afterAll(async ({}, testInfo) => {
      // Generate consolidated report for this suite
      await generateConsolidatedReport(suiteName, testInfo);
    });
  });

  test.describe('Travel Page Accessibility', () => {
    const suiteName = 'Travel Page Accessibility';

    test('should not have accessibility violations on travel page', async ({
      page,
    }) => {
      // Navigate to the travel page
      await page.goto('/travel');
      await page.waitForLoadState('domcontentloaded');

      // Wait for dynamic content to load
      await page.waitForLoadState('networkidle');

      // Run accessibility scan and collect violations
      await collectAccessibilityViolations(page, 'Travel Page', suiteName);
    });

    test('should have accessible header navigation', async ({ page }) => {
      await page.goto('/travel');
      await page.waitForLoadState('domcontentloaded');

      // Check logo link is accessible
      const logoLink = page.locator('header a[href="/"]').first();
      await expect(logoLink).toBeVisible();

      // Check Import/Export buttons have accessible names
      const importButton = page.getByRole('button', { name: /Import/i }).first();
      await expect(importButton).toBeVisible();

      // Run accessibility scan on header
      const header = page.locator('header');
      const accessibilityScanResults = await new AxeBuilder({ page })
        .include(await header.elementHandle().then((el) => el!))
        .withTags(['wcag2a', 'wcag2aa'])
        .analyze();

      expect(accessibilityScanResults.violations).toEqual([]);
    });

    test('should have accessible dropdown menus', async ({ page }) => {
      await page.goto('/travel');
      await page.waitForLoadState('domcontentloaded');

      // Open Import dropdown
      const importButton = page.getByRole('button', { name: /Import/i }).first();
      await importButton.click();

      // Wait for dropdown to appear
      await expect(page.getByText('From PDF')).toBeVisible();

      // Run accessibility scan on dropdown
      const accessibilityScanResults = await new AxeBuilder({ page })
        .withTags(['wcag2a', 'wcag2aa'])
        .analyze();

      // Check for menu-related violations
      const menuViolations = accessibilityScanResults.violations.filter((v) =>
        Boolean(
          v.id.includes('menu') ||
            v.id.includes('aria') ||
            v.id.includes('role'),
        ),
      );

      expect(menuViolations).toEqual([]);
    });

    test.afterAll(async ({}, testInfo) => {
      // Generate consolidated report for this suite
      await generateConsolidatedReport(suiteName, testInfo);
    });
  });

  test.describe('Color Contrast Validation', () => {
    test('should detect color contrast violations when present', async ({
      page,
    }) => {
      // Create a page with known bad contrast for validation
      await page.setContent(`
        <!DOCTYPE html>
        <html>
          <head>
            <title>Color Contrast Test</title>
          </head>
          <body>
            <button style="background-color: #888; color: #999; padding: 10px;">
              Low Contrast Button
            </button>
            <p style="color: #777; background-color: #888;">
              Low contrast text
            </p>
          </body>
        </html>
      `);

      // Run accessibility scan
      const accessibilityScanResults = await new AxeBuilder({
        page,
      }).analyze();

      // Expect violations to be found
      expect(accessibilityScanResults.violations.length).toBeGreaterThan(0);

      // Check that at least one violation is related to color contrast
      const contrastViolation = accessibilityScanResults.violations.find(
        (v) => v.id === 'color-contrast',
      );
      expect(contrastViolation).toBeDefined();
    });

    test('should pass with good color contrast', async ({ page }) => {
      // Create a page with good contrast
      await page.setContent(`
        <!DOCTYPE html>
        <html>
          <head>
            <title>Good Contrast Test</title>
          </head>
          <body>
            <button style="background-color: #000; color: #fff; padding: 10px;">
              Good Contrast Button
            </button>
            <p style="color: #000; background-color: #fff;">
              Good contrast text
            </p>
          </body>
        </html>
      `);

      // Run accessibility scan
      const accessibilityScanResults = await new AxeBuilder({
        page,
      }).analyze();

      // Should have no color contrast violations
      const contrastViolation = accessibilityScanResults.violations.find(
        (v) => v.id === 'color-contrast',
      );
      expect(contrastViolation).toBeUndefined();
    });
  });

  test.describe('Specific WCAG Rules', () => {
    test('should have valid ARIA attributes on landing page', async ({
      page,
    }) => {
      await page.goto('/');
      await page.waitForLoadState('domcontentloaded');

      const accessibilityScanResults = await new AxeBuilder({ page })
        .withTags(['wcag2a', 'wcag2aa'])
        .analyze();

      // Check for ARIA-related violations
      const ariaViolations = accessibilityScanResults.violations.filter((v) =>
        Boolean(v.id.includes('aria') || v.tags.includes('aria')),
      );

      expect(ariaViolations).toEqual([]);
    });

    test('should have valid ARIA attributes on travel page', async ({
      page,
    }) => {
      await page.goto('/travel');
      await page.waitForLoadState('domcontentloaded');

      const accessibilityScanResults = await new AxeBuilder({ page })
        .withTags(['wcag2a', 'wcag2aa'])
        .analyze();

      // Check for ARIA-related violations
      const ariaViolations = accessibilityScanResults.violations.filter((v) =>
        Boolean(v.id.includes('aria') || v.tags.includes('aria')),
      );

      expect(ariaViolations).toEqual([]);
    });

    test('should have proper heading hierarchy on landing page', async ({
      page,
    }) => {
      await page.goto('/');
      await page.waitForLoadState('domcontentloaded');

      const accessibilityScanResults = await new AxeBuilder({ page })
        .withTags(['wcag2a', 'wcag2aa'])
        .analyze();

      // Check for heading order violations
      const headingViolations = accessibilityScanResults.violations.filter(
        (v) => v.id === 'heading-order',
      );

      expect(headingViolations).toEqual([]);
    });

    test('should have proper heading hierarchy on travel page', async ({
      page,
    }) => {
      await page.goto('/travel');
      await page.waitForLoadState('domcontentloaded');

      const accessibilityScanResults = await new AxeBuilder({ page })
        .withTags(['wcag2a', 'wcag2aa'])
        .analyze();

      // Check for heading order violations
      const headingViolations = accessibilityScanResults.violations.filter(
        (v) => v.id === 'heading-order',
      );

      expect(headingViolations).toEqual([]);
    });

    test('should have accessible interactive elements on landing page', async ({
      page,
    }) => {
      await page.goto('/');
      await page.waitForLoadState('domcontentloaded');

      const accessibilityScanResults = await new AxeBuilder({ page })
        .withTags(['wcag2a', 'wcag2aa'])
        .analyze();

      // Check for button and link violations
      const interactiveViolations = accessibilityScanResults.violations.filter(
        (v) =>
          Boolean(
            v.id.includes('button') ||
              v.id.includes('link') ||
              v.id.includes('interactive'),
          ),
      );

      expect(interactiveViolations).toEqual([]);
    });

    test('should have accessible interactive elements on travel page', async ({
      page,
    }) => {
      await page.goto('/travel');
      await page.waitForLoadState('domcontentloaded');

      const accessibilityScanResults = await new AxeBuilder({ page })
        .withTags(['wcag2a', 'wcag2aa'])
        .analyze();

      // Check for button and link violations
      const interactiveViolations = accessibilityScanResults.violations.filter(
        (v) =>
          Boolean(
            v.id.includes('button') ||
              v.id.includes('link') ||
              v.id.includes('interactive'),
          ),
      );

      expect(interactiveViolations).toEqual([]);
    });
  });

  test.describe('Keyboard Navigation', () => {
    test('should be keyboard navigable on landing page', async ({ page }) => {
      await page.goto('/');
      await page.waitForLoadState('domcontentloaded');

      // Tab through interactive elements
      await page.keyboard.press('Tab');

      // Check that focus is visible
      const focusedElement = await page.evaluate(() => {
        const el = document.activeElement;
        return el?.tagName;
      });

      expect(focusedElement).toBeTruthy();
    });

    test('should be keyboard navigable on travel page', async ({ page }) => {
      await page.goto('/travel');
      await page.waitForLoadState('domcontentloaded');

      // Tab through interactive elements
      await page.keyboard.press('Tab');

      // Check that focus is visible
      const focusedElement = await page.evaluate(() => {
        const el = document.activeElement;
        return el?.tagName;
      });

      expect(focusedElement).toBeTruthy();
    });

    test('should navigate using Enter key on buttons', async ({ page }) => {
      await page.goto('/');
      await page.waitForLoadState('domcontentloaded');

      // Focus on manual entry button and press Enter
      const manualButton = page.getByRole('button', {
        name: /add travel dates manually/i,
      });
      await manualButton.focus();
      await page.keyboard.press('Enter');

      // Should navigate to travel page
      await expect(page).toHaveURL(/\/travel/);
    });
  });

  test.describe('Mobile Accessibility', () => {
    test('should be accessible on mobile viewport (landing page)', async ({
      page,
    }) => {
      // Set mobile viewport
      await page.setViewportSize({ width: 375, height: 667 });
      await page.goto('/');
      await page.waitForLoadState('domcontentloaded');

      // Run accessibility scan
      const accessibilityScanResults = await new AxeBuilder({ page })
        .withTags(['wcag2a', 'wcag2aa'])
        .analyze();

      expect(accessibilityScanResults.violations).toEqual([]);
    });

    test('should be accessible on mobile viewport (travel page)', async ({
      page,
    }) => {
      // Set mobile viewport
      await page.setViewportSize({ width: 375, height: 667 });
      await page.goto('/travel');
      await page.waitForLoadState('domcontentloaded');

      // Run accessibility scan
      const accessibilityScanResults = await new AxeBuilder({ page })
        .withTags(['wcag2a', 'wcag2aa'])
        .analyze();

      expect(accessibilityScanResults.violations).toEqual([]);
    });
  });
});

/**
 * Collects accessibility violations and fails the test if any are found.
 * Violations are stored for suite-level consolidated reporting in afterAll hooks.
 */
async function collectAccessibilityViolations(
  page: Page,
  testName: string,
  suiteName: string,
): Promise<void> {
  // Run accessibility scan with WCAG 2.1 AA standards
  const accessibilityScanResults = await new AxeBuilder({ page })
    .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])
    .disableRules(['meta-viewport'])
    .analyze();

  // Store violations for suite-level reporting (stored BEFORE test fails)
  if (!suiteViolations.has(suiteName)) {
    suiteViolations.set(suiteName, []);
  }

  suiteViolations.get(suiteName)!.push({
    testName,
    url: page.url(),
    violations: accessibilityScanResults.violations,
  });

  // Log results
  if (accessibilityScanResults.violations.length > 0) {
    console.log(
      `❌ ${testName}: ${accessibilityScanResults.violations.length} violation(s)`,
    );
  } else {
    console.log(`✅ ${testName}: No violations`);
  }

  // Fail the test if violations found (violations already stored above)
  expect(accessibilityScanResults.violations).toEqual([]);
}

/**
 * Generates consolidated report for a suite
 */
async function generateConsolidatedReport(
  suiteName: string,
  testInfo: TestInfo,
): Promise<void> {
  const records = suiteViolations.get(suiteName) || [];

  // Always generate a report, even if no violations (for transparency)
  const report = generateReport(suiteName, records);

  // Include browser/project name in filename to prevent overwrites across different browser runs
  const projectName = testInfo.project.name.toLowerCase().replace(/\s+/g, '-');
  const filename = `accessibility-report-${projectName}-${suiteName
    .toLowerCase()
    .replace(/\s+/g, '-')}.md`;

  // Attach to Playwright test results
  await testInfo.attach(filename, {
    body: report,
    contentType: 'text/markdown',
  });

  // Write to accessibility-reports directory (separate from playwright-report to avoid cleanup)
  const reportDir = path.join(
    process.cwd(),
    '..',
    '..',
    'accessibility-reports',
  );
  if (!fs.existsSync(reportDir)) {
    fs.mkdirSync(reportDir, { recursive: true });
  }
  fs.writeFileSync(path.join(reportDir, filename), report, 'utf-8');

  console.log(
    `Generated accessibility report: ${filename} (${records.length} test records, ${records.reduce((sum, r) => sum + r.violations.length, 0)} violations)`,
  );
}

/**
 * Generates GitHub-ready accessibility report
 */
function generateReport(suiteName: string, records: ViolationRecord[]): string {
  let report = `# Accessibility Issues: ${suiteName}\n\n`;
  report += `**Generated**: ${new Date().toISOString()}\n\n`;

  // Calculate total violations
  const totalViolations = records.reduce(
    (sum, r) => sum + r.violations.length,
    0,
  );

  if (totalViolations === 0) {
    report += `✅ **No accessibility violations found!**\n`;
    return report;
  }

  report += `**Total Issues**: ${totalViolations}\n\n`;

  // Group all violations by ID
  const violationsById = new Map<
    string,
    { violation: AxeResult; record: ViolationRecord }[]
  >();

  records.forEach((record) => {
    record.violations.forEach((violation) => {
      if (!violationsById.has(violation.id)) {
        violationsById.set(violation.id, []);
      }
      violationsById.get(violation.id)!.push({ violation, record });
    });
  });

  // Generate issue tickets
  let ticketNumber = 1;

  violationsById.forEach((entries, violationId) => {
    const firstViolation = entries[0].violation;
    const impactLevel = firstViolation.impact || 'unknown';
    const priority = getPriority(impactLevel);

    report += `---\n\n`;
    report += `## Ticket ${ticketNumber}: ${firstViolation.help}\n\n`;

    // Ticket metadata
    report += `**Priority**: ${priority}\n`;
    report += `**Impact**: ${impactLevel.toUpperCase()}\n`;
    report += `**Rule ID**: \`${violationId}\`\n`;
    report += `**WCAG**: ${firstViolation.tags
      .filter((t) => t.startsWith('wcag'))
      .join(', ')}\n\n`;

    // Description
    report += `### Description\n\n`;
    report += `${firstViolation.description}\n\n`;

    // Affected elements
    const totalElements = entries.reduce(
      (sum, e) => sum + e.violation.nodes.length,
      0,
    );
    report += `### Affected Elements\n\n`;
    report += `**Total**: ${totalElements} element(s)\n\n`;

    // Technical details
    report += `### Technical Details\n\n`;
    report += `<details>\n`;
    report += `<summary><strong>View affected elements</strong></summary>\n\n`;

    entries[0].violation.nodes.forEach((node: NodeResult, idx: number) => {
      report += `#### Element ${idx + 1}\n\n`;
      report += `**Selector**: \`${node.target.join(' ')}\`\n\n`;
      report += `**HTML**:\n\`\`\`html\n${node.html}\n\`\`\`\n\n`;
      report += `**Issue**: ${node.failureSummary}\n\n`;

      if (node.any && node.any.length > 0) {
        report += `**Fix any of**:\n`;
        node.any.forEach((fix) => {
          report += `- ${fix.message}\n`;
        });
        report += `\n`;
      }

      if (node.all && node.all.length > 0) {
        report += `**Fix all of**:\n`;
        node.all.forEach((fix) => {
          report += `- ${fix.message}\n`;
        });
        report += `\n`;
      }
    });

    report += `</details>\n\n`;

    // Acceptance criteria
    report += `### Acceptance Criteria\n\n`;
    report += `- [ ] All \`${violationId}\` violations are resolved\n`;
    report += `- [ ] Accessibility tests pass without violations\n`;
    report += `- [ ] Manual testing confirms proper functionality\n\n`;

    // Resources
    report += `### Resources\n\n`;
    report += `- [WCAG Documentation](${firstViolation.helpUrl})\n`;
    report += `- [Axe Rule: ${violationId}](${firstViolation.helpUrl})\n\n`;

    ticketNumber++;
  });

  return report;
}

/**
 * Maps impact level to priority
 */
function getPriority(impact: string): string {
  switch (impact.toLowerCase()) {
    case 'critical':
      return 'P1 - Critical';
    case 'serious':
      return 'P2 - High';
    case 'moderate':
      return 'P3 - Medium';
    case 'minor':
      return 'P4 - Low';
    default:
      return 'P3 - Medium';
  }
}
